# Java-Review-Note——1.Java基础知识

标签： JavaStudy

---

## 1.面向过程与面向对象的对比

举个简单的例子来帮助理解：平时玩的棋类游戏

面向过程要思考的是：(**步骤**)
> 
**开始游戏** 
-> **甲方先走** -> **绘制棋盘** -> **判断输赢** 
-> **乙方走** -> **绘制棋盘** -> **判断输赢** 
-> 重复上面两个过程，直到输出最后结果

面向对象要思考的是：(**功能**)
> 
分为三个部分(对象)：**玩家对象**，**棋盘系统**，**规则系统**
流程如下：
甲乙两个**玩家对象**，负责接收用户的下子(输入)，然后告诉**棋盘系统**
棋局的变化，同时刷新棋盘，并且利用**规则系统**进行输赢，是否犯规
等的判定。

**思考**：

> 相比前者，面向对象表现得更为灵活，试想如果想加一个
悔棋功能，哪个会更容易实现点？

**笼统定义**：将生活中的对象进行描述,通过类的形式,描述事物的属性和行为
面向对象是从宏观来看待问题的,面向过程则是从微观来解析问题


----------

## 2.Java相关名词

**四种技术架构**：**JAVASE**,**JAVAEE**,**JAVEME**(嵌入式,已过时),**JavaCard**(适用于智能卡的Java平台)

**Java主要优点**：

> **面向对象**,**跨平台**,**多线程**,**安全**,**简单和健壮性**,以及**改进了的解释性**:
为了弥补解释语言较慢的不足,Java采用预编译方法,生成字节代码,有些JAVA环境用JIT编译器将
字节码编译成机械码,直接运行,针对重复执行的服务端软件可以达到C的速度。

**JVM** **Java虚拟机**(Java Vitual Machine)

> 
是一种想象中的机器,在实际计算机上通过软件模拟来实现,在Java运行环境中处于可信地位,
它使得Java可以跨平台执行,包含一套**字节码指令集**,**一组寄存器**,**一个栈**,**一个垃圾回收堆**
和**一个存储方法域**
> 
**运行原理**:在任何一个平台上都给编译程序一个共同的接口,Java源程序经过编译器编译后变成字节码,
字节码再由虚拟机解释执行,虚拟机将每条执行的字节码送给解释器,解释器翻译成特定机器上的机器码
最后在特定的机器上运行

**JRE与JDK**

> 
**JRE**(Java Runtime Enviroment)**运行时环境**: JVM  + 核心类库
**JDK**(Java Development  Kit)**开发工具集**: JRE  + 编译器

**JVM的垃圾回收机制**(Garbage Collection)

> 
回收的是没有任何引用指向的对象空间,一般情况下Java会**自动进行垃圾收集**
如果想要手动请求垃圾收集,可以调用**system.gc()**或者**finalize()**方法建议;
也仅仅是**建议**而已,并**不能精确地控制垃圾回收机制的执行**

**环境变量配置**：
> 
新建：**JAVA_HOME**：jdk的安装路径，比如：C:\Program Files\Java\jdk 
修改：**PATH**，光标移到最前面(Home键)，添加：%JAVA_HOME%\bin;
新建：**CLASSPATH**，添加：%JAVA_HOME%\lib\tools.jar; 

**Java代码的运行原理**：

![][1]


----------

## 3.基础知识


----------


### 运算符


----------


**算术运算符**(12个)

![][2] 

**需要注意**：

> 
- 如果除号的前后都是整型,那么结果也为整型       eg:5 / 2 = 2
- 求余运算符通常用于整型,当然浮点型也可以,但结果是不准确的,但对精度要求
较高时就不要了,可以使用**BigDecimal**类型
- 自增和自减作为前缀还是后缀的问题：**前缀**:先自增,后参与运算 **后缀**:先参与运算,后自增
比如，这样的程序
> 
![][3]
> 
输出结果：
>
![][4]
> 
你算对了没?对付这种自增自减的问题,更重要的是细心,还有一点要注意的是:
自增自减运算符只能**对单个变量起作用**,表达式和常量是没用的
eg:(a + b)++  想让相加后的结果+1,但是确是错的,
同样,常量也是不行的,6++,这样也是错的！切记！


----------


**逻辑运算符**(7个)

![][5]

**需要注意**：

**短路现象**，区分**逻辑与/或** 和 **短路与/或** 的区别，短路与/或
之前前置条件为真/假，后面就不会判断了，结果一定为**真/假**


----------


**三元运算符**：

**a ? b : c**

如果a成立执行b，不成立执行c，精简版的if-else，另外要注意，b，c 需为**表达式**，即
有返回值！


----------


**位运算符**(7个)：

![][6]
> 
**<<**： 左移1位等于乘以2
**>>**： 右移一位等于除以2;再取整,移位溢出的丢弃
**>>>**： 无符号右移 最高位不是用原来的最高位填充,而是直接用0来填充最高位
**~**：按位取反，~a = - a -1
**&**：操作数都为1结果为1,否则结果为0 
**|**：操作数都为0,结果才为0,否则为1
**^**：操作数相同为0,不同结果为1


不用第三个变量交换两个变量的值得方法

①**利用他们的和**：a = a + b;b = a - b;a = a - b;
②**用^运算符**：a = a^b; b = a^b; a = a^b;


**编码相关常识**：
> 
**原码**：最高位为符号位，比如8位二进制对应的取值范围为：
[1111 1111,0111 1111]   即：[-127,127]
> 
**反码**：正数反码不变；负数最高位不变，其他位取反
比如:
[+1] = [0000 0001]原 = [0000 0001]反
[-1] = [1000 0001]原 = [1111 1110]反 一般转换成原码后才能看出他的数值
> 
**补码**：正数补码不变；求反码后 最低位 + 1
比如：
[+1] = [00000001]原 = [00000001]反 = [00000001]补
[-1] = [10000001]原 = [11111110]反 = [11111111]补 同样也是需要转成原码才能看出值
> 
计算机加入符号位会使基础电路变得十分复杂，1 - 1 = 1 + (-1) = 0
那么机器就可以只有加法没有减法，演变过程：
**原码**：0000 0001 + 1000 0001 = 1000 0002 = -2 
=> **反码**：原式 = [0000 0001]反 + [1111 1110]反 = 1111 1111 = -0
0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0
=> **补码**：原式 = [0000 0001]补 + [1111 1111]补 = 0000 0000 = 0
-0的问题解决了，还能表示多一个最低数，比如[-127,127]用补码：[-128,127]

**进制转换**

**所有进制转十进制**：**权值相加**，示例如下：
> 
二级制(0,1)： 1011 = 1*2^3 + 0*2^2 + 1*2^1 + 1*2^0 = 11
八进制(0～7)： 53 = 5*8^1 + 3*8^0 = 43
十六进制(0123456789ABCDEF)： 2B = 2*16^1 + 12*16^0 = 43

**十进制转其他进制**：**一直求余法**或**先转二进制**再转

**二进制与八进制互转**：**三合一法**，不够补零；
> 
比如：11010111.0100111转八进制
小数点左边部分：011 010 111 右边部分010 011 100 => 327.234
如果是八转二：**取一分三法**，如327 = 011 010 111

**二进制与十六进制互转**：**四合一法**和**取一分四法**，和八进制类同，略..

**八进制与十六进制互转**：先转二进制，再转


----------


**运算符优先级**：

![][7]


----------

### 数据类型

**基本数据类型**：

整型:**int**,**short**,**long**,**byte**;都是有符号的
浮点型:**float**,**double**
字符型:**char**
布尔值:**boolean**

**要注意**：

> 
①Java中,如果是想表示float类型的必须在后面**加后缀F**,如果没有后缀的话会被**默认**为**double类型**
②在Java中**char占用两个字节**哦!因为Java使用**Unicode** 16位的编码方式,可以表示所有的字符
③布尔值boolean只有两个值:要么是**true**,要么是**false**,不能用1,0来表示真假！

**数据类型的自动转换**：

**自动转换**(隐式):如果满足以下两个条件就会进行自动转换:
①**转换后的类型比原来的类型大**    ②**转换前后类型相互兼容**
比如:两个byte变量相加后，结果是int类型
**强制转换**(显式)，前面加个(数据类型)，需注意精度丢失的问题

**包装类相关**

我们可以直接调封装器类的下述方法获得对应参数，以Integer为例

Integer.MAX_VALUE = 0x7FFFFFFF; //正数最大值
Integer.MIN_VALUE = 0x80000000; //负数最大值
Integer.SIZE = 32;  //字节数

Integer还提供了几个进制转换的方法

转二进制：**toBinaryString**()
转八进制：**toOctalString**()
转十六进制：**toHexString**()
二，八，十六转十进制：**decode**()

另外int和Integer可以直接比较是否相等，因为Java会自解装，如果
是两个Integer比较，需要掉**intValue**()方法进行比较；或者调
**compareTo**方法也行。


----------

### 常量与变量

**需注意的**：
> 
对于局部变量,当我们想要使用一个变量的时候,要先对他进行初始化,不然编译器会报错！！！
而例外的情况:实例变量与类变量,编译器会自动地对他们进行初始化
默认：boolean变量 为false,char默认为'\000'


----------

### 字符串

**字符串相关的操作方法**

> 
- 1.字符串的连接:用"+"加号可以连接成字符串,比如: 123 + "" = "123"
- 2.求字符串的长度:  str.**length**()
- 3.求子串:str.**subString**(开始下标,"结束下标")    //注意是从0开始算的
- 4.判断是否相等:这里要注意==这个比较的是字符串是否存储在同一位置!如果是比较内容我们要用equals("");
- 5.返回给定下标处的字符:   str.**charAt**(int index);  //从0开始算的
- 6.将指定字符串连接到字符串的尾部:  str.**concat**("HeHe");
- 7.检索某字符在字符串中第一次出现的下标:  str.**indexOf**("a");
- 8.检索某字符在字符串中最后一次出现的下标：str.**lastIndexOf**("a")；
- 9.去掉头尾的空白:str.**trim**(),这个在数据库操作中比较常用
- 10.替换字符串中的某段: str.**replace**("想替换的字符串","替换后的字符串");
- 11.比较两个字符串的大小,无视大小写：str.**equalsIgnoreCase**(stg);
- 12.全部字符转化为小写:str.**toLowerCase**()
- 13.全部字符转化为大写:str.**toUpperCase**();
- 14.切割字符串，返回字符串数组：str.**split**(String)，比如有：abcdeabcab
split("a")会返回一个字符串数组：{"bcde","bc","b"}，转义字符要注意！！！
另外还有另外一个构造方法可以对多个字符进行分割，比如：split(new char{'c','d','e'})
- 15.字符串拼接：使用concat比+好，当然前提是拼接的两个都是字符串，字符串
拼接首选StringBuffer！

**需注意**：

**问**：String str = "abc"   str = "cba"那么string对象是否会发生改变呢?
答：不会，str只是作为一个引用指向一个字符串存储的内存空间，str存储的只是
一个地址，当我们定义字符串变量时,系统会先对String常量池中的字符串进行匹配
有的话直接使用已经存在的字符串常量,否则在池中再生成一个！


----------

### 程序流程控制

**if语句**：**else语句总是和其最近if语句相互搭配**，当然前提是他们在同一块中
**switch**：要注意的就是记得**给每个case写个break**，不然每个都会执行一遍
**while**和**do-while()**的区别：**无论条件是否成立，后者至少执行一次**
**for(初始化,条件判断,迭代)**：循环嵌套时一定要有条件跳出循环，小心死循环
**break语句**：可以直接终止循环,多层嵌套时,跳出一层循环
**continue语句**：直接停止本次循环的剩余语句,直接进行下一次循环
**return语句**：只能用在方法(函数)中,结束当前的方法

----------

### 数组

> 
- **创建**：int[] array = new int[3]; //定义一个容量为3的整型数组
- **初始化**：定义的时候初始化，或者利用for循环进行赋初值
- **使用**：**获取长度**：array.length; **数组复制**：长度，类型相同的
直接数组名赋值就好；main()的参数拿来用，命令行下可以在java ... 后添加参数
- **多维数组**：**Java的多数组的列数可以是数目不同的**！
例子如下：

```
public class arrayTest {  
    public static void main(String[] args) {  
        //①直接一开始赋初值  
        int[][] array1 =   
        {  
                {1,2,3},  
                {4,5,6},  
                {7,8,9}  
        };  
          
        //②创建规则的二维数组 5*3的  
        int [][] array2 = new int[5][3];          
        //③创建不规则的二维数组:3行,列数依次为:3,2,1  
        int [][] array3 = new int[3][];  
        //指定每一行的列数  
        array3[0]= new int[3];  
        array3[1]= new int[2];  
        array3[2]= new int[1];                
        //赋值
        for(int i = 0;i < array3.length;i++)  
        {  
            for(int j = 0;j < array3[i].length;j++)  
            {   ...  }  
        }  
    }  
}  
```




----------


  [1]: http://static.zybuluo.com/coder-pig/0scwwofxwuqhxkgbd4ieuiww/1.png
  [2]: http://static.zybuluo.com/coder-pig/c1s5o0ctmcvc01y6jam2nsrl/2.png
  [3]: http://static.zybuluo.com/coder-pig/l5b0fotupdu6gya9hdzs44y7/3.png
  [4]: http://static.zybuluo.com/coder-pig/3pv3lwejrvoxxn2gljaweup0/4.png
  [5]: http://static.zybuluo.com/coder-pig/cvb9upbppqor6qvn1pth164s/image_1at87vpl6apvu8mul1untpj72v.png
  [6]: http://static.zybuluo.com/coder-pig/8rcbn2pouf5d116dniw8zp1l/image_1at88b2kh1qqcnki5f6pmo13a33c.png
  [7]: http://img.blog.csdn.net/20140326093956984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY29kZXJfcGln/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast